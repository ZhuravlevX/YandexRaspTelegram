import json
import time
import requests
from datetime import datetime
import pytz
import asyncio
import random
from aiogram import Bot, Dispatcher, executor, types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, InputMediaPhoto
import logging

with open('config.json', 'r') as config_file:
    config = json.load(config_file)
token_yandex = config.get('token_yandex')
token_bot = config.get('token_bot')

api_url = f'https://api.rasp.yandex.net/v3.0/stations_list/?apikey={token_yandex}&lang=ru_RU&format=json'

bot = Bot(token=token_bot)
dp = Dispatcher(bot)

logging.basicConfig(level=logging.INFO)

image_urls = [
    'https://rozklad.spb.ru/images/articles/dlya-chego-nuzhna-elektrichka.jpg',
    'https://www.msk-guide.ru/img/11971/MskGuide.ru_165366big.jpg',
    'https://s0.rbk.ru/v6_top_pics/media/img/0/76/756708342242760.jpg',
    'https://tmholding.ru/upload/iblock/9ef/9ef8fa7cb1c2c46d3188a312d6cb5d9a.jpg',
    'https://moscowchanges.ru/wp-content/uploads/2019/10/IMG_0485.jpg',
    'https://i.ytimg.com/vi/Rqy7pN_ArXY/maxresdefault.jpg',
    'https://upload.wikimedia.org/wikipedia/commons/a/a0/ED2T-0041-hero.jpg',
    'https://railgallery.ru/photo/00/34/29/34297.jpg'
]

auto_update_users = {}
current_messages = {}

def get_trains():
    date = datetime.now().strftime('%Y-%m-%d')
    moscow_tz = pytz.timezone('Europe/Moscow')
    moscow_now = datetime.now(moscow_tz)

    rasp = requests.get(
        f"https://api.rasp.yandex.net/v3.0/search?apikey={token_yandex}&from=s9601636&to=s2000003&lang=ru_RU&date={date}&transport_types=suburban&limit=131"
    )
    trains = rasp.json().get("segments", [])
    info = rasp.json().get("search", {})

    train_info = []
    count = 0

    from_title = info.get("from", {}).get("title", "–ù–µ —É–∫–∞–∑–∞–Ω–æ")
    to_title = info.get("to", {}).get("title", "–ù–µ —É–∫–∞–∑–∞–Ω–æ")

    for train in trains:
        dep = datetime.fromisoformat(train["departure"])
        arr = datetime.fromisoformat(train["arrival"])

        if moscow_now.timestamp() > dep.timestamp():
            continue

        ticket_price = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å"
        if train.get("tickets_info") and train["tickets_info"].get("places"):
            place_info = train["tickets_info"]["places"][0]
            if place_info.get("price"):
                ticket_price = f'{place_info["price"].get("whole", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å")} —Ä—É–±–ª–µ–π'

        train_info.append(
            f'üöÜ <b>{train["thread"]["number"]} {train["thread"]["title"]}</b>\n'
            f'<i>–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è —Å {train.get("departure_platform", "–ù–µ —É–∫–∞–∑–∞–Ω–æ")} –≤ {dep.hour}:{dep.minute:02d}</i>\n'
            f'<i>–° –æ—Å—Ç–∞–Ω–æ–≤–∫–∞–º–∏: {train.get("stops", "–ù–µ —É–∫–∞–∑–∞–Ω–æ")}</i>\n'
            f'<i>–°—Ç–æ–∏–º–æ—Å—Ç—å –±–∏–ª–µ—Ç–∞: {ticket_price}</i>\n'
            f'<i>{train["thread"].get("transport_subtype", {}).get("title", "–ü—Ä–∏–≥–æ—Ä–æ–¥–Ω—ã–π –ø–æ–µ–∑–¥")} | {train["thread"]["carrier"]["title"]}</i>\n'
        )

        count += 1
        if count >= 4:
            break

    if train_info:
        return f"üìã <b>–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –ø–æ–µ–∑–¥–æ–≤ –æ—Ç \"{from_title}\" –¥–æ \"{to_title}\" –Ω–∞ {date}</b>\n\n" + "\n".join(train_info)
    else:
        return None

async def update_trains(message: types.Message, user_id: int):
    global auto_update_users, current_messages
    remaining_time = 60
    auto_update_users[user_id] = True
    current_messages[user_id] = message

    for i in range(60):
        current_time = datetime.now().strftime('%H:%M')
        train_info = get_trains()
        random_image = random.choice(image_urls)

        if not auto_update_users[user_id]:
            train_info += f"\nüöÜüö´<b> –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±—ã–ª–æ –æ—Ç–º–µ–Ω–µ–Ω–æ. –ü–æ—Å–ª–µ–¥–Ω–∏–µ –¥–∞–Ω–Ω—ã–µ –±—ã–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã –≤ {current_time}.</b>"
            media = InputMediaPhoto(media=random_image, caption=train_info, parse_mode='HTML')
            await message.edit_media(media)
            auto_update_users[user_id] = False
            return

        if train_info:
            if i < 59:
                remaining_time -= 1
                additional_text = f"\n<b>üöÜ‚åõ –°–ª–µ–¥—É—é—â–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 1 –º–∏–Ω—É—Ç—É. –û—Å—Ç–∞–≤—à–µ–µ—Å—è –≤—Ä–µ–º—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: {remaining_time} –º–∏–Ω—É—Ç.</b>"
            else:
                additional_text = f"\n<b>üöÜ‚åõ –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±—ã–ª–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ –≤ {current_time}, —É—á—Ç–∏—Ç–µ –∞–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è!</b>"

            train_info += additional_text
            keyboard = InlineKeyboardMarkup().add(
                InlineKeyboardButton("üö´ | –û—Ç–º–µ–Ω–∏—Ç—å –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ", callback_data=f"cancel_update_{user_id}"))
            media = InputMediaPhoto(media=random_image, caption=train_info, parse_mode='HTML')
            await message.edit_media(media, reply_markup=keyboard)
        else:
            await message.edit_text(
                "üöÜüö´ <b>–ù–∞ —Ç–µ–∫—É—â–∏–π –º–æ–º–µ–Ω—Ç, –Ω–∞ –¥–∞–Ω–Ω—É—é –¥–∞—Ç—É –∏–ª–∏ –∑–∞–¥–∞–Ω–æ–º—É –º–∞—Ä—à—Ä—É—Ç—É –º—ã –Ω–µ –Ω–∞—à–ª–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—É—â—É—é –∏–ª–∏ –∂–µ –¥–∞–ª—å–Ω–µ–π—à—É—é –¥–∞—Ç—É –¥–ª—è —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –∏ –ø—Ä–æ–≤–µ—Ä—å—Ç–µ, –ø—Ä–∞–≤–∏–ª—å–Ω–æ –ª–∏ –≤—ã —É–∫–∞–∑–∞–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏—è —Å—Ç–∞–Ω—Ü–∏–π –¥–ª—è –º–∞—Ä—à—Ä—É—Ç–∞.</b>",
                parse_mode='HTML')
        await asyncio.sleep(60)

    auto_update_users[user_id] = False

@dp.message_handler(commands=['start'])
async def send_welcome(message: types.Message):
    keyboard = InlineKeyboardMarkup().add(
        InlineKeyboardButton("‚¨Ö | –£–∫–∞–∑–∞—Ç—å –º–∞—Ä—à—Ä—É—Ç", callback_data="button1"),
        InlineKeyboardButton("üìã | –£–∑–Ω–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ", callback_data="button2")
    )
    random_image = random.choice(image_urls)
    await message.answer_photo(photo=random_image, caption="üìã <b>–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–∏–≥–æ—Ä–æ–¥–Ω—ã—Ö —ç–ª–µ–∫—Ç—Ä–∏—á–µ–∫ –∏ —ç–∫—Å–ø—Ä–µ—Å—Å–æ–≤</b>\n\n"
                               "–î–∞–Ω–Ω—ã–π –±–æ—Ç –ø–æ–∑–≤–æ–ª—è–µ—Ç –≤–∞–º –±—ã—Å—Ç—Ä–æ —É–∑–Ω–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –æ–± –≤–∞—à–µ–º –ø–æ–µ–∑–¥–µ. –î–ª—è —ç—Ç–æ–≥–æ –Ω—É–∂–Ω–æ –ª–∏—à—å —É–∫–∞–∑–∞—Ç—å –æ—Ç–∫—É–¥–∞ –∏ –∫—É–¥–∞ –≤–∞–º –Ω–∞–¥–æ –ø—Ä–∏–µ—Ö–∞—Ç—å –∏ –ø–æ—è–≤–∏—Ç—å—Å—è –ø–æ–ª–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –±–ª–∏–∂–∞—â–∏—Ö –ø—Ä–∏–≥–æ—Ä–æ–¥–Ω—ã—Ö —ç–ª–µ–∫—Ç—Ä–∏—á–µ–∫ –∏ –ø–æ–µ–∑–¥–∞—Ö.\n\n"
                               "–î–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –∏–∑–º–µ–Ω–∏—Ç—å –∏–ª–∏ —É–∑–Ω–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –ø–æ —Ç–µ–∫—É—â–∏–º —É–∫–∞–∑–∞–Ω–∏—è–º –º–∞—Ä—à—Ä—É—Ç–∞, –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ.", parse_mode='HTML', reply_markup=keyboard)

@dp.message_handler(commands=['trains'])
async def send_trains(message: types.Message):
    global auto_update_users, current_messages
    user_id = message.from_user.id

    if auto_update_users.get(user_id, False):
        await message.reply("üöÜüìã <b>–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ —Å –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –∞–∫—Ç–∏–≤–Ω–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–∫–ª—é—á–∏—Ç–µ —Ç–µ–∫—É—â–µ–µ –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º –Ω–æ–≤–æ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è.</b>", parse_mode='HTML')
        return

    initial_message = await message.reply("üöÜüìã <b>–ü–æ–ª—É—á–∞–µ–º —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –ø–æ–µ–∑–¥–æ–≤...</b>", parse_mode='HTML')
    await update_trains(initial_message, user_id)

@dp.callback_query_handler(lambda c: c.data.startswith('cancel_update_'))
async def cancel_update(callback_query: types.CallbackQuery):
    global auto_update_users
    user_id = int(callback_query.data.split('_')[-1])
    auto_update_users[user_id] = False
    await bot.answer_callback_query(callback_query.id,
    text="üö´‚åõ –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±—ã–ª–æ –æ—Ç–º–µ–Ω–µ–Ω–æ, —É—á—Ç–∏—Ç–µ —á—Ç–æ –¥–∞–Ω–Ω—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–µ–∞–∫—Ç—É–∞–ª—å–Ω—ã–º–∏. –û—Ç–º–µ–Ω–∞ –ø—Ä–æ–∏–∑–æ–π–¥–µ—Ç –≤ —Ç–µ—á–µ–Ω–∏–∏ –º–∏–Ω—É—Ç—ã.")
    await bot.edit_message_reply_markup(callback_query.message.chat.id, callback_query.message.message_id, reply_markup=None)

@dp.callback_query_handler(lambda c: c.data == "button2")
async def handle_button2(callback_query: types.CallbackQuery):
    await send_trains(callback_query.message)

async def on_shutdown(dp):
    global current_messages
    for user_id, message in current_messages.items():
        current_time = datetime.now().strftime('%H:%M')
        await bot.send_message(message.chat.id, f"\nüöÜüö´ <b>–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–∏–ª —Å–≤–æ—é —Ä–∞–±–æ—Ç—É. –≠—Ç–æ —Å–≤—è–∑–∞–Ω–æ —Å —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–º–∏ —Ä–∞–±–æ—Ç–∞–º–∏ –∏ –æ—à–∏–±–∫–∞–º–∏. –ü–æ—Å–ª–µ–¥–Ω–µ–µ –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–∞—à–µ–≥–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –±—ã–ª–æ –≤ {current_time}. –ë—É–¥—å—Ç–µ –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω—ã –∏ —Å–ª–µ–¥–∏—Ç–µ –∑–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ–º!</b>", parse_mode='HTML')
    await dp.storage.close()
    await dp.storage.wait_closed()

if __name__ == '__main__':
    executor.start_polling(dp, skip_updates=True, on_shutdown=on_shutdown)
